{"version":3,"file":"static/js/MinMaxWorker.774d1c00.worker.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","quoridor/Move.ts","quoridor/Notation.ts","quoridor/Player.ts","quoridor/State.ts","agents/minMax.ts","agents/evaluateState.ts","agents/MinMaxWorker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import { Pos } from \"./State\";\n\nexport enum Orientation {\n    Vertical='v',\n    Horizontal='h',\n}\n\nexport type PawnMove = {\n    target: Pos,\n}\n\nexport type WallMove = {\n    square: Pos\n    orientation: Orientation,\n}\n\nexport type Move = WallMove | PawnMove;\n","import { Move, Orientation } from \"./Move\";\nimport { Pos } from \"./State\";\n\nexport type Notation = string;\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nexport function isPawnMove(notation: Notation): boolean {\n    return !(notation.endsWith(Orientation.Vertical) || notation.endsWith(Orientation.Horizontal));\n}\n\nexport function posToString(pos: Pos): string {\n    if (pos[0] < 0 || pos[0] >= ALPHABET.length)\n        throw new Error(\"Board is to large to be represented by standard notation\");\n    return ALPHABET[Math.floor(pos[0] / 2)] + Math.ceil(pos[1] / 2);\n}\n\nexport function notationToPos(notation: Notation): Pos {\n    const row = ALPHABET.indexOf(notation[0]);\n    const column = Number.parseInt(notation.substring(1));\n    return [2 * row + 1, 2 * column - 1]\n}\n// maybe check validity with a regex\nexport function notationToMove(notation: string): Move {\n    if (notation.endsWith(Orientation.Vertical) || notation.endsWith(Orientation.Horizontal)) {\n        const orientation = notation.endsWith(Orientation.Vertical) ? Orientation.Vertical : Orientation.Horizontal;\n\n        const row = ALPHABET.indexOf(notation[0]);\n        const column = Number.parseInt(notation.substring(1, notation.length - 1));\n        if (orientation === Orientation.Horizontal) {\n            const pos = [2 * row, 2 * column - 1]\n            return {\n                square: pos,\n                orientation\n            }\n        } else {\n            const pos = [2 * row + 1, 2 * column]\n            return {\n                square: pos,\n                orientation\n            }\n        }\n    } else {\n        return {\n            target: notationToPos(notation),\n        }\n    }\n}\n\nexport function moveToNotation({ move }: { move: Move; }): string {\n    if ('target' in move) {\n        return posToString(move.target);\n    } else {\n        if (move.orientation === Orientation.Vertical) {\n            return posToString(move.square) + 'v';\n        } else {\n            return posToString(move.square) + 'h';\n        }\n    }\n}\n","export enum Player {\n    white = 0,\n    black = 1\n}\n","/*\n * Think about abstracting to a more general game\n * - k pawns per player\n * So far only 2 are supported\n * pawnPositions[0] for white and ...[1] for black\n * - arbitrary board size\n * - But I would restrict it to a 2-player game\n */\n\nimport { Orientation, type Move, type WallMove } from \"./Move\";\nimport { moveToNotation, Notation, notationToMove, notationToPos, posToString } from \"./Notation\";\nimport { Player } from \"./Player\";\n\nexport interface GameSettings {\n    boardWidth?: number,\n    boardHeight?:  number,\n    walls?: number,\n    pawns?: number,\n}\n\nexport type MandatoryGameSettings = {\n    boardWidth: number,\n    boardHeight:  number,\n    walls: number,\n    pawns: number,\n}\n\nexport const GameSettingsDefaults: MandatoryGameSettings = {\n    boardWidth: 9,\n    boardHeight:  9,\n    walls: 10,\n    pawns: 1,\n}\n\nexport type Pos = number[];\nexport type Board = Int8Array[];\n\nexport class State {\n    // We can index these variables with currentPlayer\n    pawnPositions: Array<Pos>;\n    wallsAvailable: Array<number>;\n    // There could be made an argument that we could store which player the wall belongs to\n    // But for the game and the sake of simplicity it is not important\n    board: Board;\n    settings: MandatoryGameSettings;\n    currentPlayer: Player;\n    width: number;\n    height: number;\n    illegal = false;\n    shortestPaths : number[];\n    private precomputedMoves: Set<Notation> | undefined;\n    private _children: Map<Notation, State> | undefined;\n\n    constructor(settings: GameSettings = GameSettingsDefaults) {\n        this.settings = { ...GameSettingsDefaults, ...settings };\n        this.wallsAvailable = [this.settings.walls, this.settings.walls];\n        // The size of the internal matrix representation\n        this.width = this.settings.boardWidth * 2 + 1;\n        this.height = this.settings.boardHeight * 2 + 1;\n        this.shortestPaths = [this.settings.boardHeight, this.settings.boardHeight];\n        const middle = Math.ceil(this.settings.boardWidth / 2);\n        this.pawnPositions = [\n            [1, middle * 2 - 1],\n            [this.height - 2, middle * 2 - 1],\n        ];\n        this.board = new Array(this.height)\n            .fill(0)\n            .map(() => new Int8Array(this.width).fill(-1));\n\n        // Hack: surround the board with walls that we do not have to do bounds checking\n        for (let i=0;i<this.height;i++) {\n            this.board[i][0] = 1;\n            this.board[i][this.width - 1] = 1;\n        }\n        for (let j=0;j<this.width;j++) {\n            this.board[0][j] = 1;\n            this.board[this.height - 1][j] = 1;\n        }\n        // White begins\n        this.currentPlayer = Player.white;\n    }\n\n\n\n    isLegal(move: Move | Notation): boolean {\n        // If we generate all legal moves anyways we can just check if the move is in that list\n        // But in some cases it may be better for performance if we have a separate check here\n        // Need the deepEqual because wallMove is a nested object\n        if (typeof move === 'string') {\n            return this.legalMoves.has(move);\n        } else {\n            return this.legalMoves.has(moveToNotation({ move }));\n        }\n    }\n\n    winner(): Player | null {\n        // Check if a pawn is on the finish line.\n        // Not sure: what happens if you would jump over finish line\n        if (this.pawnPositions[Player.white][0] >= this.height - 2) {\n            return Player.white;\n        } else if (this.pawnPositions[Player.black][0] <= 1) {\n            return Player.black;\n        }\n        return null;\n    }\n\n    isGameOver(): boolean {\n        return this.winner() !== null;\n    }\n\n    placeWall(move: WallMove, board: Board): void {\n        const [ row, column ] = move.square;\n        if (move.orientation === Orientation.Horizontal) {\n            board[row][column] = 1;\n            board[row][column + 2] = 1;\n        } else {\n            board[row][column] = 1;\n            board[row + 2][column] = 1;\n        }\n    }\n\n    makeMove(move: Move|Notation): State {\n        // We expect moves to use the internal representations\n        // try to make it immutable and return\n        // a new State instead of modifying this one?\n        if (typeof move === 'string') {\n            if (this.legalMoves.has(move)) {\n                const res = this.children.get(move);\n                if (res) return res;\n            }\n            move = notationToMove(move);\n        }\n        const newState = new State(this.settings);\n\n        for (let i=0;i<this.height;i++) {\n            for (let j=0;j<this.width;j++) {\n                newState.board[i][j] = this.board[i][j];\n                if (i % 2 == 0 && j % 2 == 0) { // crosses\n                    newState.board[i][j] = -1;\n                }\n                if (i % 2 == 1 && j % 2 == 1) { // crosses\n                    newState.board[i][j] = -1;\n                }\n            }\n        }\n        newState.pawnPositions = [...this.pawnPositions];\n        newState.wallsAvailable = [...this.wallsAvailable];\n        newState.currentPlayer = this.currentPlayer === Player.white ? Player.black : Player.white;\n\n        // I would like have a type guard here like move typeof PawnMove\n        // But the type information is not available at runtime...\n        // That's why we have to use this ugly in operator narrowing\n        if ('target' in move) {\n            newState.pawnPositions[this.currentPlayer] = move.target;\n        } else {\n            newState.placeWall(move, newState.board);\n            newState.wallsAvailable[this.currentPlayer]--;\n        }\n        // recreate distField if necessary\n        // TODO: check if we can skip recomputing\n        const d1 = newState.whiteBFS(newState.pawnPositions[Player.white]);\n        if (d1 === -1) newState.illegal = true;\n        newState.shortestPaths[Player.white] = d1;\n        const d = newState.blackBFS(newState.pawnPositions[Player.black]);\n        if (d === -1) newState.illegal = true;\n        newState.shortestPaths[Player.black] = d;\n        return newState;\n    }\n\n    generateManhattanMoves(pos: Pos, board: Board): Array<Pos> {\n        const [row, col] = pos;\n        const ns = [\n            [row + 2, col],\n            [row, col + 2],\n            [row, col - 2],\n            [row - 2, col],\n        ];\n        const ws = [\n            board[row + 1][col],\n            board[row][col + 1],\n            board[row][col - 1],\n            board[row - 1][col],\n        ];\n        return ns.filter((_, i) => ws[i] != 1);\n    }\n\n    generatePawnMoves(pawnPos: Pos): Array<Move> {\n        // All adjacent squares\n        const res: Move[] = [];\n        const enemyPos = this.pawnPositions[this.opponent];\n        this.generateManhattanMoves(pawnPos, this.board).forEach(c => {\n            if (c[0] === enemyPos[0] && c[1] === enemyPos[1]) {\n                // Jumps are possible!\n                const direction = [(enemyPos[0] - pawnPos[0])/2, (enemyPos[1] - pawnPos[1])/2];\n                const behind = [enemyPos[0] + direction[0], enemyPos[1] + direction[1]];\n                // But there may be a wall behind him\n                if (this.board[behind[0]][behind[1]] !== 1) {\n                    res.push({\n                            target: [behind[0] + direction[0], behind[1] + direction[1]]\n                        })\n                } else {\n                    for (c of this.generateManhattanMoves(enemyPos, this.board)) {\n                        if (enemyPos[0] !== pawnPos[0] || enemyPos[1] !== pawnPos[1]) {\n                            res.push({\n                                target: c\n                            })\n                        }\n                    }\n                }\n            } else {\n                res.push({\n                    target: c\n                });\n            }\n        });\n        return res;\n    }\n\n    get opponent(): Player {\n        return this.currentPlayer === Player.white ? Player.black : Player.white;\n    }\n\n    whiteBFS(start: Pos): number {\n        const q: number[][] = [start];\n        this.board[start[0]][start[1]] = 0;\n        while (q.length > 0) {\n            const v = q.shift();\n            if (!v) continue;\n            const [row, col] = v;\n            if (row >= this.height - 2) {\n                return this.board[row][col];\n            }\n            const ns = [\n                [row + 2, col],\n                [row, col + 2],\n                [row, col - 2],\n                [row - 2, col],\n            ];\n            const ws = [\n                this.board[row + 1][col],\n                this.board[row][col + 1],\n                this.board[row][col - 1],\n                this.board[row - 1][col],\n            ];\n            ns.forEach(([y, x], i) => {\n                if (ws[i] !== 1 && this.board[y][x] === -1) {\n                    this.board[y][x] = this.board[row][col] + 1;\n                    q.push([y, x]);\n                }\n            })\n        }\n        return -1;\n    }\n\n    blackBFS(start: Pos) {\n        // Shift everything by -1, -1 when storing or accessing dists\n        // This way we can use the empty spaces between walls to store this in the board matrix\n        const q: number[][] = [start];\n        this.board[start[0] - 1][start[1] - 1] = 0;\n        while (q.length > 0) {\n            const v = q.shift();\n            if (!v) continue;\n            const [row, col] = v;\n            if (row <= 1) {\n                return this.board[row-1][col-1];\n            }\n            const ns = [\n                [row + 2, col],\n                [row, col + 2],\n                [row, col - 2],\n                [row - 2, col],\n            ];\n            const ws = [\n                this.board[row + 1][col],\n                this.board[row][col + 1],\n                this.board[row][col - 1],\n                this.board[row - 1][col],\n            ];\n            ns.forEach(([y, x], i) => {\n                if (ws[i] !== 1 && this.board[y - 1][x - 1] === -1) {\n                    this.board[y-1][x-1] = this.board[row-1][col-1] + 1;\n                    q.push([y, x]);\n                }\n            })\n        }\n        return -1;\n    }\n\n    generateWallMoves(): Array<Move> {\n        // Iterate over board row by row\n        // Check if a wall could be placed either vertically or horizontally\n        // Problem: crossing walls\n        const moves: Array<Move> = [];\n        if (this.wallsAvailable[this.currentPlayer] === 0) {\n            return moves;\n        }\n        // We will run a number of checks that will filter out candidates\n        // 1. The wall may not overlap with other walls\n        // 2. It may not cross another wall\n        // 3. The enemy pawn must still be able to win (this will be checked only later)\n\n        // Vertical walls\n        for (let i=1;i<this.height-3; i+=2) {\n            for (let j=2;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1) continue;\n                if (this.board[i + 2][j] === 1) continue;\n                if (this.board[i + 1][j - 1] === 1 && this.board[i + 1][j + 1] === 1) continue;\n                const move = {\n                    square: [i, j],\n                    orientation: Orientation.Vertical,\n                };\n                moves.push(move);\n            }\n        }\n        // Horizontal walls\n        for (let i=2;i<this.height-1; i+=2) {\n            for (let j=1;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1) continue;\n                if (this.board[i][j + 2] === 1) continue;\n                if (this.board[i - 1][j + 1] === 1 && this.board[i + 1][j + 1] === 1) continue;\n                const move = {\n                        square: [i, j],\n                        orientation: Orientation.Horizontal,\n                    }\n                moves.push(move);\n            }\n        }\n        return moves;\n    }\n\n    generateAllMoves(): Array<Move> {\n        let moves: Array<Move> = [];\n        if (!this.isGameOver()) {\n            moves = this.generatePawnMoves(this.pawnPositions[this.currentPlayer]);\n            moves = moves.concat(this.generateWallMoves());\n        }\n        return moves;\n    }\n\n    computeChildren(): Map<Notation, State> {\n        const m = new Map<Notation, State>();\n        this.precomputedMoves = new Set<Notation>();\n        // for all Moves (not necessarily legal)\n        const moves = this.generateAllMoves(); // not so legal any more\n        for (const move of moves) {\n            const notation: Notation = moveToNotation({ move });\n            const newState = this.makeMove(move);\n            if (!newState.illegal) {\n                this.precomputedMoves.add(notation);\n                m.set(notation, newState);\n            }\n        }\n        return m;\n    }\n\n    get children(): Map<string, State> {\n        if (this._children === undefined) {\n            this._children = this.computeChildren();\n        }\n        return this._children;\n    }\n\n    get legalMoves(): Set<Notation> {\n        if (!this.precomputedMoves) {\n            this.precomputedMoves = new Set<Notation>();\n            this.computeChildren();\n        }\n        return this.precomputedMoves;\n    }\n\n    toString(): string {\n        // ASCII art less go\n        let res = \"\";\n        for (let i=1;i<this.height-1; i++) {\n            for (let j=1;j<this.width-1; j++) {\n                if (i % 2 === 0 && j % 2 === 0) {\n                    if (this.board[i][j] === 1) {\n                        // res += \"■\";\n                        res += \"+\";\n                    } else {\n                        res += \"+\";\n                    }\n                } else if (i % 2 !== j % 2) {\n                    if (this.board[i][j] === 1) {\n                        res += \"■\";\n                    } else {\n                        res += \" \";\n                    }\n                } else if (i % 2 === 1 && j % 2 === 1) {\n                    if (this.pawnPositions[Player.white][0] === i && this.pawnPositions[Player.white][1] === j) {\n                        res += \"○\";\n                    } else if (this.pawnPositions[Player.black][0] === i && this.pawnPositions[Player.black][1] === j) {\n                        res += \"●\";\n                    } else {\n                        res += \".\";\n                    }\n                }\n            }\n            res += \"\\n\";\n        }\n        return res;\n    }\n\n    toNotation(): string {\n       let notation = \"\";\n\n        // Horizontal walls\n        for (let i=2;i<this.height-1; i+=2) {\n            for (let j=1;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1 && this.board[i][j + 2] === 1) {\n                    notation += posToString([i, j]) + \" \";\n                    j+=2;\n                }\n            }\n        }\n        notation += \"/\";\n        // Vertical walls\n        for (let j=2;j<this.width - 2; j+=2) {\n            for (let i=1;i<this.height-3; i+=2) {\n                if (this.board[i][j] === 1 && this.board[i+2][j] === 1) {\n                    notation += posToString([i, j]) + \" \";\n                    i+=2;\n                }\n            }\n        }\n        notation += \"/\";\n        notation += posToString(this.pawnPositions[0]);\n        notation += \" \" + posToString(this.pawnPositions[1]);\n        notation += \"/\";\n        notation += this.wallsAvailable[0];\n        notation += \" \" + this.wallsAvailable[1];\n        notation += \"/\";\n        notation += this.currentPlayer;\n\n        return notation;\n    }\n\n    static fromNotation(notation: string, settings: GameSettings): State {\n        const state = new State(settings);\n        const regex = /(.*)\\/(.*)\\/(.*) (.*)\\/(\\d+) (\\d+)\\/(\\d)/;\n        const matches = notation.match(regex);\n        try {\n            if (matches && matches.length === 8) {\n                if (matches[1] !== null) {\n                    const hwalls = matches[1].trim();\n                    if (hwalls.length > 0) {\n                        for (const wall of hwalls.split(\" \")) {\n                            const move = notationToMove(wall + Orientation.Horizontal) as WallMove\n                            state.placeWall(move , state.board);\n                        }\n                    }\n                }\n                if (matches[2] !== null) {\n                    const vwalls = matches[2].trim();\n                    if (vwalls.length > 0) {\n                        for (const wall of vwalls.split(\" \")) {\n                            const move = notationToMove(wall + Orientation.Vertical) as WallMove\n                            state.placeWall(move, state.board);\n                        }\n                    }\n                }\n                state.pawnPositions[0] = notationToPos(matches[3]);\n                state.pawnPositions[1] = notationToPos(matches[4]);\n                state.wallsAvailable[0] = Number.parseInt(matches[5]);\n                state.wallsAvailable[1] = Number.parseInt(matches[6]);\n                state.currentPlayer = matches[7] === \"1\" ? Player.black : Player.white;\n\n                state.shortestPaths[Player.white] = state.whiteBFS(state.pawnPositions[Player.white]);\n                state.shortestPaths[Player.black] = state.blackBFS(state.pawnPositions[Player.black]);\n                return state;\n            } else {\n                console.error(\"invalid matches\", matches);\n                throw new Error(\"Invalid State notation\");\n            }\n        } catch (e) {\n            console.log(notation, matches, e);\n            throw new Error(\"Invalid State notation\");\n        }\n    }\n}\n","import { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\nimport { evaluateState } from \"./evaluateState\";\n\nexport function shuffleArray(arr: Array<any>) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}\n\nexport function minMax({ state, alpha, beta, maxPlayer, depth, maximizing}: { state: State; alpha: number; beta: number; maxPlayer: Player; depth: number; maximizing: boolean; }): number {\n  if (state.isGameOver()) {\n    return state.winner() === maxPlayer ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  }\n\n  if (depth <= 0) {\n    return evaluateState(state, maxPlayer);\n  }\n\n  const kids = [...state.children.values()];\n  shuffleArray(kids);\n  // console.log(`Recursively exploring all ${state.legalMoves.length} moves with depth ${depth}`);\n  if (maximizing) {\n    let value = Number.NEGATIVE_INFINITY;\n    for (const child of kids) {\n      value = Math.max(value, minMax({ state: child, alpha, beta, maxPlayer, depth: depth - 1, maximizing: false }));\n      alpha = Math.max(alpha, value);\n      if (value >= beta) {\n        break;\n      }\n    }\n    return value;\n  } else {\n    let value = Number.POSITIVE_INFINITY;\n    for (const child of kids) {\n      value = Math.min(value, minMax({ state: child, alpha, beta, maxPlayer, depth: depth - 1, maximizing: true }));\n      beta = Math.min(beta, value);\n      if (value <= alpha) {\n        break;\n      }\n    }\n    return value;\n  }\n}\n","import { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\n\n\nexport function evaluateState(state: State, evalPlayer: Player) {\n  // (already computed) Perform BFS for both pawns to get distance to finishline\n  const d1 = state.shortestPaths[evalPlayer];\n  const otherPlayer = evalPlayer === Player.white ? Player.black : Player.white;\n  const d2 = state.shortestPaths[otherPlayer];\n  if (state.wallsAvailable[0] + state.wallsAvailable[1] === 0) {\n    // The one with shorter distance wins\n    // But check if a jump could influence it!\n    // TODO: do it correctly with taking account for jumps\n    // jumps should not be a problem if difference bigger than 1\n    // or the distance to the enemy pawn is farther than to the end\n    // Wait: we can just play it out\n  }\n  // factor in the walls available\n  return d2 - d1 + 0 * state.wallsAvailable[evalPlayer] - 0 * state.wallsAvailable[otherPlayer] + Math.random();\n  // return (30-d1) + d2 + 10 +  Math.random() * 5;\n}\n","import { State } from \"../quoridor/State\";\nimport { minMax } from \"./minMax\";\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as any;\n\n\nonmessage = function(e) {\n  const [move, stateNotation, settings, alpha, beta, maxPlayer, depth, maximizing] = e.data;\n  try {\n    const state = State.fromNotation(stateNotation, settings);\n    const value = minMax({state, alpha, beta, maxPlayer, depth, maximizing});\n    // ctx.postMessage(value);\n    postMessage([move, value]);\n  } catch (e) {\n    console.error(e, stateNotation);\n  }\n}\n\n\nexport {};\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","_toConsumableArray","iter","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","Orientation","Player","ALPHABET","posToString","pos","Error","Math","floor","ceil","notationToPos","notation","indexOf","Number","parseInt","substring","notationToMove","endsWith","orientation","row","column","square","moveToNotation","move","GameSettingsDefaults","boardWidth","boardHeight","walls","pawns","State","settings","pawnPositions","wallsAvailable","board","currentPlayer","width","height","illegal","shortestPaths","precomputedMoves","_children","this","middle","fill","map","Int8Array","j","white","protoProps","staticProps","state","matches","match","hwalls","trim","split","placeWall","vwalls","black","whiteBFS","blackBFS","console","error","log","legalMoves","has","winner","res","children","get","newState","d1","d","col","ns","ws","_","pawnPos","enemyPos","opponent","generateManhattanMoves","c","direction","behind","start","q","v","shift","y","x","moves","isGameOver","generatePawnMoves","concat","generateWallMoves","m","Map","Set","generateAllMoves","makeMove","add","set","undefined","computeChildren","minMax","alpha","beta","maxPlayer","depth","maximizing","POSITIVE_INFINITY","NEGATIVE_INFINITY","evalPlayer","otherPlayer","d2","random","evaluateState","kids","values","shuffleArray","child","max","min","self","onmessage","data","stateNotation","fromNotation","postMessage"],"sourceRoot":""}