{"version":3,"file":"static/js/Worker.6116add7.worker.js","mappings":"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","sources":["../webpack/bootstrap","quoridor/Move.ts","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","quoridor/Notation.ts","quoridor/Player.ts","quoridor/State.ts","agents/utils.ts","agents/minMax.ts","agents/evaluateState.ts","agents/ShortestPathAgent.ts","agents/Worker.ts","agents/MCTSNode.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import { Pos } from \"./State\";\n\nexport enum Orientation {\n    Vertical='v',\n    Horizontal='h',\n}\n\nexport type PawnMove = {\n    target: Pos,\n}\n\nexport type WallMove = {\n    square: Pos\n    orientation: Orientation,\n}\n\nexport type Move = WallMove | PawnMove;\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import { Move, Orientation } from \"./Move\";\nimport { Pos } from \"./State\";\n\nexport type Notation = string;\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nexport function isPawnMove(notation: Notation): boolean {\n    return !(notation.endsWith(Orientation.Vertical) || notation.endsWith(Orientation.Horizontal));\n}\n\nexport function posToString(pos: Pos): string {\n    if (pos[0] < 0 || pos[0] >= ALPHABET.length)\n        throw new Error(\"Board is to large to be represented by standard notation\");\n    return ALPHABET[Math.floor(pos[0] / 2)] + Math.ceil(pos[1] / 2);\n}\n\nexport function notationToPos(notation: Notation): Pos {\n    const row = ALPHABET.indexOf(notation[0]);\n    const column = Number.parseInt(notation.substring(1));\n    return [2 * row + 1, 2 * column - 1]\n}\n// maybe check validity with a regex\nexport function notationToMove(notation: string): Move {\n    if (notation.endsWith(Orientation.Vertical) || notation.endsWith(Orientation.Horizontal)) {\n        const orientation = notation.endsWith(Orientation.Vertical) ? Orientation.Vertical : Orientation.Horizontal;\n\n        const row = ALPHABET.indexOf(notation[0]);\n        const column = Number.parseInt(notation.substring(1, notation.length - 1));\n        if (orientation === Orientation.Horizontal) {\n            const pos = [2 * row, 2 * column - 1]\n            return {\n                square: pos,\n                orientation\n            }\n        } else {\n            const pos = [2 * row + 1, 2 * column]\n            return {\n                square: pos,\n                orientation\n            }\n        }\n    } else {\n        return {\n            target: notationToPos(notation),\n        }\n    }\n}\n\nexport function moveToNotation({ move }: { move: Move; }): string {\n    if ('target' in move) {\n        return posToString(move.target);\n    } else {\n        if (move.orientation === Orientation.Vertical) {\n            return posToString(move.square) + 'v';\n        } else {\n            return posToString(move.square) + 'h';\n        }\n    }\n}\n","export enum Player {\n    white = 0,\n    black = 1\n}\n","/*\n * Think about abstracting to a more general game\n * - k pawns per player\n * So far only 2 are supported\n * pawnPositions[0] for white and ...[1] for black\n * - arbitrary board size\n * - But I would restrict it to a 2-player game\n */\n\nimport { Orientation, PawnMove, type Move, type WallMove } from \"./Move\";\nimport { moveToNotation, Notation, notationToMove, notationToPos, posToString } from \"./Notation\";\nimport { Player } from \"./Player\";\n\nexport interface GameSettings {\n    boardWidth?: number,\n    boardHeight?:  number,\n    walls?: number,\n    pawns?: number,\n}\n\nexport type MandatoryGameSettings = {\n    boardWidth: number,\n    boardHeight:  number,\n    walls: number,\n    pawns: number,\n}\n\nexport const GameSettingsDefaults: MandatoryGameSettings = {\n    boardWidth: 9,\n    boardHeight:  9,\n    walls: 10,\n    pawns: 1,\n}\n\nexport type Pos = number[];\nexport type Board = Int8Array[];\n\nexport class State {\n    // We can index these variables with currentPlayer\n    pawnPositions: Array<Pos>;\n    wallsAvailable: Array<number>;\n    // There could be made an argument that we could store which player the wall belongs to\n    // But for the game and the sake of simplicity it is not important\n    board: Board;\n    settings: MandatoryGameSettings;\n    currentPlayer: Player;\n    width: number;\n    height: number;\n    illegal = false;\n    shortestPaths : number[];\n    turn = 0;\n    private precomputedMoves: Set<Notation> | undefined;\n    private _children: Map<Notation, State> | undefined;\n\n    constructor(settings: GameSettings = GameSettingsDefaults, root?: boolean) {\n        this.settings = { ...GameSettingsDefaults, ...settings };\n        this.wallsAvailable = [this.settings.walls, this.settings.walls];\n        // The size of the internal matrix representation\n        this.width = this.settings.boardWidth * 2 + 1;\n        this.height = this.settings.boardHeight * 2 + 1;\n        this.shortestPaths = [this.settings.boardHeight, this.settings.boardHeight];\n        const middle = Math.ceil(this.settings.boardWidth / 2);\n        this.pawnPositions = [\n            [1, middle * 2 - 1],\n            [this.height - 2, middle * 2 - 1],\n        ];\n        this.board = new Array(this.height)\n            .fill(0)\n            .map(() => new Int8Array(this.width).fill(-1));\n\n        if (root) {\n            // Hack: surround the board with walls that we do not have to do bounds checking\n            for (let i=0;i<this.height;i++) {\n                this.board[i][0] = 1;\n                this.board[i][this.width - 1] = 1;\n            }\n            for (let j=0;j<this.width;j++) {\n                this.board[0][j] = 1;\n                this.board[this.height - 1][j] = 1;\n            }\n\n            this.whiteBFS();\n            this.blackBFS();\n        }\n        // White begins\n        this.currentPlayer = Player.white;\n    }\n\n\n\n    isLegal(move: Move | Notation): boolean {\n        // If we generate all legal moves anyways we can just check if the move is in that list\n        // But in some cases it may be better for performance if we have a separate check here\n        // Need the deepEqual because wallMove is a nested object\n        if (typeof move === 'string') {\n            return this.legalMoves.has(move);\n        } else {\n            return this.legalMoves.has(moveToNotation({ move }));\n        }\n    }\n\n    winner(): Player | null {\n        // Check if a pawn is on the finish line.\n        // Not sure: what happens if you would jump over finish line\n        if (this.pawnPositions[Player.white][0] >= this.height - 2) {\n            return Player.white;\n        } else if (this.pawnPositions[Player.black][0] <= 1) {\n            return Player.black;\n        }\n        return null;\n    }\n\n    result(player: Player) {\n        if (this.isGameOver()) {\n            return this.winner() === player ? 1 :  0;\n        } else {\n            return this.automaticPlayout() === player ? 1 : 0;\n        }\n    }\n\n    isGameOver(): boolean {\n        return this.winner() !== null;\n    }\n\n    get automaticPlayoutPossible(): boolean {\n        return this.wallsAvailable[0] === 0 && this.wallsAvailable[1] === 0;\n    }\n\n    automaticPlayout(): Player|null {\n        // If the distance difference is big enough it does not matter\n        const ddiff = this.shortestPaths[this.currentPlayer] - this.shortestPaths[this.opponent];\n        if (ddiff >= 2) {\n            // console.log(\"Decisive diff for opponent player\");\n            return this.opponent;\n        } else if (ddiff <= -2) {\n            // console.log(\"Decisive diff for curr\");\n            return this.currentPlayer;\n        } else {\n            // console.log(\"Playout depends on jumps\");\n            // Find jump dist\n            // Check that all squares on the shortest paths for the current player are jumpable\n            let depth = this.shortestPaths[this.currentPlayer] - 1;\n            let layer = new Set<Pos>();\n            layer.add(this.pawnPositions[this.currentPlayer]);\n            let jumpFlag = false;\n            // let jumpAll = true;\n            let currPaths = new Array(this.height).fill(0).map(()=>new Array(this.width).fill(-1));\n            while (depth > 0) {\n                let nextLayer = new Set<Pos>();\n                // console.log(layer, depth);\n                for (const [row, col] of layer.values()) {\n                    const ns =  [\n                        [row + 2, col],\n                        [row, col + 2],\n                        [row, col - 2],\n                        [row - 2, col],\n                    ];\n                    const ws = [\n                        this.board[row + 1][col],\n                        this.board[row][col + 1],\n                        this.board[row][col - 1],\n                        this.board[row - 1][col],\n                    ];\n                    // if (jumpFlag && this.board[row][col] !== this.board[row-1][col-1]) {\n                    //    jumpAll = false;\n                    // }\n                    if (this.board[row][col] !== -1 && this.board[row][col] === this.board[row-1][col-1]) {\n                        jumpFlag = true;\n                        // JUMPABLE\n                    } else {\n                        ns.forEach(([i, j], ind) => {\n                            if (ws[ind] === 1 || i < 0 || i >= this.height || j < 0 || j >= this.width) return;\n                            if (currPaths[i][j] !== -1) return;\n                            if (this.currentPlayer === Player.white && this.board[i][j] === depth) {\n                                nextLayer.add([i, j]);\n                                currPaths[i][j] = depth;\n                            } else if (this.currentPlayer === Player.black && this.board[i-1][j-1] === depth) {\n                                nextLayer.add([i, j]);\n                                currPaths[i][j] = depth;\n                            }\n                        })\n                    }\n                }\n                if (jumpFlag) break;\n                layer = nextLayer;\n                depth--;\n            }\n            /*\n             * Wrong:\n             * also compute the shortest paths for the opponent\n             * Annoying: arrays in sets do not work as expected :(\n             */\n            const jumpDist = depth;\n            // console.log(jumpDist, layer);\n            depth = this.shortestPaths[this.opponent] - 1;\n            layer = new Set<Pos>();\n            layer.add(this.pawnPositions[this.opponent]);\n            const otherPaths = new Array(this.height).fill(0).map(()=>new Array(this.width).fill(-1));\n            while (depth > jumpDist) {\n                let nextLayer = new Set<Pos>();\n                // console.log(layer, depth);\n                for (const [row, col] of layer.values()) {\n                    const ns =  [\n                        [row + 2, col],\n                        [row, col + 2],\n                        [row, col - 2],\n                        [row - 2, col],\n                    ];\n                    const ws = [\n                        this.board[row + 1][col],\n                        this.board[row][col + 1],\n                        this.board[row][col - 1],\n                        this.board[row - 1][col],\n                    ];\n                    ns.forEach(([i, j], ind) => {\n                        if (ws[ind] === 1 || i < 0 || i >= this.height || j < 0 || j >= this.width) return;\n                        if (otherPaths[i][j] !== -1) return;\n                        if (this.opponent === Player.white && this.board[i][j] === depth) {\n                            nextLayer.add([i, j]);\n                            otherPaths[i][j] = depth;\n                        } else if (this.opponent === Player.black && this.board[i - 1][j - 1] === depth) {\n                            nextLayer.add([i, j]);\n                            otherPaths[i][j] = depth;\n                        }\n                    })\n                }\n                layer = nextLayer;\n                depth--;\n            }\n            let flag = !!layer.size;\n            for (const [i, j] of layer) {\n                if (currPaths[i][j] === -1 || this.board[i][j] !== this.board[i-1][j-1]) {\n                    flag = false;\n                }\n            }\n            // console.log(\"ddif\", ddiff, layer, flag);\n            if (jumpFlag && flag) {\n                // console.log(\"(opponent) Can jump for all shortest paths, winner: \", this.opponent);\n            } else {\n                // console.log(\"No decisive jumps, depends on ddiff\");\n                if (ddiff > 0) {\n                    // console.log(\"opponent with 1 advantage\");\n                    return this.opponent;\n                }\n                else {\n                    // console.log(\"current because he goes first\");\n                    return this.currentPlayer;\n                }\n            }\n\n           return null;\n        }\n        // 1. ddiff >= 2 -> currentPlayer wins\n        // 2. ddiff == 1,0 and opponent can't jump -> currentPlayer wins\n        // 3. ddiff == -1 and currenPlayer can jump -> currentPlayer wins\n        // else opponent wins\n    }\n\n    placeWall(move: WallMove, board: Board): void {\n        const [ row, column ] = move.square;\n        if (move.orientation === Orientation.Horizontal) {\n            board[row][column] = 1;\n            board[row][column + 2] = 1;\n        } else {\n            board[row][column] = 1;\n            board[row + 2][column] = 1;\n        }\n    }\n\n    clone(): State {\n        const newState = new State(this.settings);\n\n        for (let i=0;i<this.height;i++) {\n            for (let j=0;j<this.width;j++) {\n                newState.board[i][j] = this.board[i][j];\n            }\n        }\n        newState.pawnPositions = [...this.pawnPositions];\n        newState.wallsAvailable = [...this.wallsAvailable];\n        newState.shortestPaths = [...this.shortestPaths];\n        newState._children = new Map(this._children);\n        newState.precomputedMoves = new Set(this.precomputedMoves);\n        return newState;\n    }\n\n    makeMove(move: Move|Notation): State {\n        // We expect moves to use the internal representations\n        // try to make it immutable and return\n        // a new State instead of modifying this one?\n        if (typeof move === 'string') {\n            if (this.legalMoves.has(move)) {\n                const res = this.children.get(move);\n                if (res) return res;\n            }\n            move = notationToMove(move);\n        }\n        const newState = new State(this.settings);\n\n        for (let i=0;i<this.height;i++) {\n            for (let j=0;j<this.width;j++) {\n                newState.board[i][j] = this.board[i][j];\n                if (i % 2 == 0 && j % 2 == 0) { // crosses\n                    newState.board[i][j] = -1;\n                }\n                if (i % 2 == 1 && j % 2 == 1) { // crosses\n                    newState.board[i][j] = -1;\n                }\n            }\n        }\n        newState.pawnPositions = [...this.pawnPositions];\n        newState.wallsAvailable = [...this.wallsAvailable];\n        newState.currentPlayer = this.currentPlayer === Player.white ? Player.black : Player.white;\n        newState.turn = this.turn + 1;\n\n        // I would like have a type guard here like move typeof PawnMove\n        // But the type information is not available at runtime...\n        // That's why we have to use this ugly in operator narrowing\n        if ('target' in move) {\n            newState.pawnPositions[this.currentPlayer] = move.target;\n        } else {\n            newState.placeWall(move, newState.board);\n            newState.wallsAvailable[this.currentPlayer]--;\n        }\n        // recreate distField if necessary\n        // TODO: check if we can skip recomputing\n        const d1 = newState.whiteBFS();\n        if (d1 === -1) newState.illegal = true;\n        newState.shortestPaths[Player.white] = d1;\n        const d = newState.blackBFS();\n        if (d === -1) newState.illegal = true;\n        newState.shortestPaths[Player.black] = d;\n        return newState;\n    }\n\n    makeMoveInplace(move: Move|Notation): State {\n        /*\n         * Modifies the state inplace.\n         */\n        if (typeof move === 'string') {\n            move = notationToMove(move);\n        }\n        this.currentPlayer = this.currentPlayer === Player.white ? Player.black : Player.white;\n        this.turn = this.turn + 1;\n        if ('target' in move) {\n            this.pawnPositions[this.currentPlayer] = move.target;\n            // if we only move a pawn the dist field does not change\n            // But wait there may be a jump possible now!\n        } else {\n            this.placeWall(move, this.board);\n            this.wallsAvailable[this.currentPlayer]--;\n            // Invalidate DIST fields\n            // TODO: check if we can skip recomputing\n            for (let i=0;i<this.height;i++) {\n                for (let j=0;j<this.width;j++) {\n                    if (i % 2 == 0 && j % 2 == 0) { // crosses\n                        this.board[i][j] = -1;\n                    }\n                    if (i % 2 == 1 && j % 2 == 1) { // crosses\n                        this.board[i][j] = -1;\n                    }\n                }\n            }\n            const d1 = this.whiteBFS();\n            if (d1 === -1) this.illegal = true;\n            this.shortestPaths[Player.white] = d1;\n            const d = this.blackBFS();\n            if (d === -1) this.illegal = true;\n            this.shortestPaths[Player.black] = d;\n        }\n        return this;\n    }\n\n    generateManhattanMoves(pos: Pos, board: Board): Array<Pos> {\n        const [row, col] = pos;\n        const ns = [\n            [row + 2, col],\n            [row, col + 2],\n            [row, col - 2],\n            [row - 2, col],\n        ];\n        const ws = [\n            board[row + 1][col],\n            board[row][col + 1],\n            board[row][col - 1],\n            board[row - 1][col],\n        ];\n        return ns.filter((_, i) => ws[i] != 1);\n    }\n\n    generatePawnMoves(pawnPos: Pos): Array<PawnMove> {\n        // All adjacent squares\n        const res: PawnMove[] = [];\n        const enemyPos = this.pawnPositions[this.opponent];\n        this.generateManhattanMoves(pawnPos, this.board).forEach(c => {\n            if (c[0] === enemyPos[0] && c[1] === enemyPos[1]) {\n                // Jumps are possible!\n                const direction = [(enemyPos[0] - pawnPos[0])/2, (enemyPos[1] - pawnPos[1])/2];\n                const behind = [enemyPos[0] + direction[0], enemyPos[1] + direction[1]];\n                // But there may be a wall behind him\n                if (this.board[behind[0]][behind[1]] !== 1) {\n                    res.push({\n                            target: [behind[0] + direction[0], behind[1] + direction[1]]\n                        })\n                } else {\n                    for (c of this.generateManhattanMoves(enemyPos, this.board)) {\n                        if (enemyPos[0] !== pawnPos[0] || enemyPos[1] !== pawnPos[1]) {\n                            res.push({\n                                target: c\n                            })\n                        }\n                    }\n                }\n            } else {\n                res.push({\n                    target: c\n                });\n            }\n        });\n        return res;\n    }\n\n    get opponent(): Player {\n        return this.currentPlayer === Player.white ? Player.black : Player.white;\n    }\n\n    whiteBFS(): number {\n        // The other direction: start on the other side\n        const q: number[][] = [];\n        for (let i=1;i<this.width;i+=2) {\n            q.push([this.height -2, i]);\n            this.board[this.height -2][i] = 0;\n        }\n        const [pr, pc] = this.pawnPositions[Player.white];\n        while (q.length > 0) {\n            const v = q.shift();\n            if (!v) continue;\n            const [row, col] = v;\n            if (row === pr && col === pc) {\n                return this.board[row][col];\n            }\n            const ns = [\n                [row + 2, col],\n                [row, col + 2],\n                [row, col - 2],\n                [row - 2, col],\n            ];\n            const ws = [\n                this.board[row + 1][col],\n                this.board[row][col + 1],\n                this.board[row][col - 1],\n                this.board[row - 1][col],\n            ];\n            ns.forEach(([y, x], i) => {\n                if (ws[i] !== 1 && this.board[y][x] === -1) {\n                    this.board[y][x] = this.board[row][col] + 1;\n                    q.push([y, x]);\n                }\n            })\n        }\n        return -1;\n    }\n\n    blackBFS() {\n        // Shift everything by -1, -1 when storing or accessing dists\n        // This way we can use the empty spaces between walls to store this in the board matrix\n        const q: number[][] = [];\n        for (let i=1;i<this.width;i+=2) {\n            q.push([1, i]);\n            this.board[0][i-1] = 0;\n        }\n        const [pr, pc] = this.pawnPositions[Player.black];\n        while (q.length > 0) {\n            const v = q.shift();\n            if (!v) continue;\n            const [row, col] = v;\n            if (row === pr && col === pc) {\n                return this.board[row-1][col-1];\n            }\n            const ns = [\n                [row + 2, col],\n                [row, col + 2],\n                [row, col - 2],\n                [row - 2, col],\n            ];\n            const ws = [\n                this.board[row + 1][col],\n                this.board[row][col + 1],\n                this.board[row][col - 1],\n                this.board[row - 1][col],\n            ];\n            ns.forEach(([y, x], i) => {\n                if (ws[i] !== 1 && this.board[y - 1][x - 1] === -1) {\n                    this.board[y-1][x-1] = this.board[row-1][col-1] + 1;\n                    q.push([y, x]);\n                }\n            })\n        }\n        return -1;\n    }\n\n    generateWallMoves(): Array<Move> {\n        // Iterate over board row by row\n        // Check if a wall could be placed either vertically or horizontally\n        // Problem: crossing walls\n        const moves: Array<Move> = [];\n        if (this.wallsAvailable[this.currentPlayer] === 0) {\n            return moves;\n        }\n        // We will run a number of checks that will filter out candidates\n        // 1. The wall may not overlap with other walls\n        // 2. It may not cross another wall\n        // 3. The enemy pawn must still be able to win (this will be checked only later)\n\n        // Vertical walls\n        for (let i=1;i<this.height-3; i+=2) {\n            for (let j=2;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1) continue;\n                if (this.board[i + 2][j] === 1) continue;\n                if (this.board[i + 1][j - 1] === 1 && this.board[i + 1][j + 1] === 1) continue;\n                const move = {\n                    square: [i, j],\n                    orientation: Orientation.Vertical,\n                };\n                moves.push(move);\n            }\n        }\n        // Horizontal walls\n        for (let i=2;i<this.height-1; i+=2) {\n            for (let j=1;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1) continue;\n                if (this.board[i][j + 2] === 1) continue;\n                if (this.board[i - 1][j + 1] === 1 && this.board[i + 1][j + 1] === 1) continue;\n                const move = {\n                        square: [i, j],\n                        orientation: Orientation.Horizontal,\n                    }\n                moves.push(move);\n            }\n        }\n        return moves;\n    }\n\n    generateAllMoves(): Array<Move> {\n        let moves: Array<Move> = [];\n        if (!this.isGameOver()) {\n            moves = this.generatePawnMoves(this.pawnPositions[this.currentPlayer]);\n            moves = moves.concat(this.generateWallMoves());\n        }\n        return moves;\n    }\n\n    computeChildren(): Map<Notation, State> {\n        const m = new Map<Notation, State>();\n        this.precomputedMoves = new Set<Notation>();\n        // for all Moves (not necessarily legal)\n        const moves = this.generateAllMoves(); // not so legal any more\n        for (const move of moves) {\n            const notation: Notation = moveToNotation({ move });\n            const newState = this.makeMove(move);\n            if (!newState.illegal) {\n                this.precomputedMoves.add(notation);\n                m.set(notation, newState);\n            }\n        }\n        return m;\n    }\n\n    get children(): Map<string, State> {\n        if (this._children === undefined) {\n            this._children = this.computeChildren();\n        }\n        return this._children;\n    }\n\n    get legalMoves(): Set<Notation> {\n        if (!this.precomputedMoves) {\n            this.precomputedMoves = new Set<Notation>();\n            this.computeChildren();\n        }\n        return this.precomputedMoves;\n    }\n\n    toString(): string {\n        // ASCII art less go\n        let res = \"\";\n        for (let i=1;i<this.height-1; i++) {\n            for (let j=1;j<this.width-1; j++) {\n                if (i % 2 === 0 && j % 2 === 0) {\n                    if (this.board[i][j] === 1) {\n                        // res += \"\";\n                        res += \"+\";\n                    } else {\n                        res += \"+\";\n                    }\n                } else if (i % 2 !== j % 2) {\n                    if (this.board[i][j] === 1) {\n                        res += \"\";\n                    } else {\n                        res += \" \";\n                    }\n                } else if (i % 2 === 1 && j % 2 === 1) {\n                    if (this.pawnPositions[Player.white][0] === i && this.pawnPositions[Player.white][1] === j) {\n                        res += \"\";\n                    } else if (this.pawnPositions[Player.black][0] === i && this.pawnPositions[Player.black][1] === j) {\n                        res += \"\";\n                    } else {\n                        res += \".\";\n                    }\n                }\n            }\n            res += \"\\n\";\n        }\n        return res;\n    }\n\n    toNotation(): string {\n       let notation = \"\";\n\n        // Horizontal walls\n        for (let i=2;i<this.height-1; i+=2) {\n            for (let j=1;j<this.width - 2; j+=2) {\n                if (this.board[i][j] === 1 && this.board[i][j + 2] === 1) {\n                    notation += posToString([i, j]) + \" \";\n                    j+=2;\n                }\n            }\n        }\n        notation += \"/\";\n        // Vertical walls\n        for (let j=2;j<this.width - 2; j+=2) {\n            for (let i=1;i<this.height-3; i+=2) {\n                if (this.board[i][j] === 1 && this.board[i+2][j] === 1) {\n                    notation += posToString([i, j]) + \" \";\n                    i+=2;\n                }\n            }\n        }\n        notation += \"/\";\n        notation += posToString(this.pawnPositions[0]);\n        notation += \" \" + posToString(this.pawnPositions[1]);\n        notation += \"/\";\n        notation += this.wallsAvailable[0];\n        notation += \" \" + this.wallsAvailable[1];\n        notation += \"/\";\n        notation += this.currentPlayer;\n\n        return notation;\n    }\n\n    static fromNotation(notation: string, settings: GameSettings): State {\n        const state = new State(settings, true);\n        const regex = /(.*)\\/(.*)\\/(.*) (.*)\\/(\\d+) (\\d+)\\/(\\d)/;\n        const matches = notation.match(regex);\n        try {\n            if (matches && matches.length === 8) {\n                if (matches[1] !== null) {\n                    const hwalls = matches[1].trim();\n                    if (hwalls.length > 0) {\n                        for (const wall of hwalls.split(\" \")) {\n                            const move = notationToMove(wall + Orientation.Horizontal) as WallMove\n                            state.placeWall(move , state.board);\n                        }\n                    }\n                }\n                if (matches[2] !== null) {\n                    const vwalls = matches[2].trim();\n                    if (vwalls.length > 0) {\n                        for (const wall of vwalls.split(\" \")) {\n                            const move = notationToMove(wall + Orientation.Vertical) as WallMove\n                            state.placeWall(move, state.board);\n                        }\n                    }\n                }\n                state.pawnPositions[0] = notationToPos(matches[3]);\n                state.pawnPositions[1] = notationToPos(matches[4]);\n                state.wallsAvailable[0] = Number.parseInt(matches[5]);\n                state.wallsAvailable[1] = Number.parseInt(matches[6]);\n                state.currentPlayer = matches[7] === \"1\" ? Player.black : Player.white;\n                state.turn = -1;\n\n                state.shortestPaths[Player.white] = state.whiteBFS();\n                state.shortestPaths[Player.black] = state.blackBFS();\n                return state;\n            } else {\n                console.error(\"invalid matches\", matches);\n                throw new Error(\"Invalid State notation\");\n            }\n        } catch (e) {\n            console.log(notation, matches, e);\n            throw new Error(\"Invalid State notation\");\n        }\n    }\n}\n","export function shuffleArray(arr: Array<any>) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}\n\nexport function selectRandomly(arr: Array<any>) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n","import { Notation } from \"../quoridor/Notation\";\nimport { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\nimport { evaluateState } from \"./evaluateState\";\nimport { shuffleArray } from \"./utils\";\nimport { workTypes } from \"./Worker\";\n\n\ntype minMaxArgs = {\n  state: State;\n  alpha: number;\n  beta: number;\n  maxPlayer: Player;\n  depth: number;\n  maximizing: boolean;\n}\n\n\nexport async function minMaxWrapper(state: State, depth: number, workers: Worker[]|null, maxPlayer: Player|null=null): Promise<Notation> {\n  maxPlayer = maxPlayer === null ? state.currentPlayer : maxPlayer;\n  let start = performance.now();\n  let alpha = Number.NEGATIVE_INFINITY;\n  let beta = Number.POSITIVE_INFINITY;\n  const kids = [...state.children.entries()];\n  shuffleArray(kids);\n  let t = Number.NEGATIVE_INFINITY;\n  let tempMove = \"\";\n\n  if (workers) {\n    const promises = [];\n    const n = kids.length;\n    const workloads = [];\n    for (let i = 0; i < workers.length - 1; i++) {\n      workloads.push(kids.splice(0, n / workers.length));\n    }\n    workloads.push(kids);\n\n    for (let i = 0; i < workers.length; i++) {\n      const worker = workers[i];\n      const load = workloads[i];\n      const data: [Notation, number][] = [];\n      const p = new Promise<[Notation, number][]>(function (resolve) {\n        // Reusing workers didnt work because onmessage was overwritten and promises were not resolved\n        worker.onmessage = function (e: MessageEvent) {\n          data.push(e.data);\n          if (data.length === load.length) {\n            resolve(data);\n          }\n        }\n        for (const [move, child] of load) {\n          const stateNotation = child.toNotation();\n          worker.postMessage([workTypes.MINMAX, move, stateNotation, state.settings, alpha, beta, maxPlayer, depth - 1, false]);\n        }\n      })\n      if (load.length) promises.push(p);\n    }\n    await Promise.all(promises)\n      .then((data) => {\n        console.log(\"All promises resolved, merging results\", data);\n        for (const part of data) {\n          for (const d of part) {\n            const move = d[0];\n            const value = d[1];\n            if (value >= t) {\n              t = value;\n              tempMove = move;\n            }\n            alpha = Math.max(alpha, t)\n            // Problem: can't break out of the loop because we are in a callback function\n            // if (t >= beta) {\n            //     break loop;\n            // }\n          }\n        }\n      });\n    console.log(`Executed alpha-beta-min-max in ${performance.now() - start} ms`)\n    return tempMove;\n  } else {\n    for (const [move, child] of kids) {\n      const value = minMax({ state: child, alpha, beta, maxPlayer, depth: depth- 1, maximizing: false });\n      if (value >= t) {\n        t = value;\n        tempMove = move;\n      }\n      alpha = Math.max(alpha, t)\n    }\n    return tempMove;\n  }\n}\n\nexport function minMax({ state, alpha, beta, maxPlayer, depth, maximizing }: minMaxArgs): number {\n  if (state.isGameOver()) {\n    return state.winner() === maxPlayer ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  }\n\n  if (depth <= 0) {\n    return evaluateState(state, maxPlayer);\n  }\n\n  const kids = [...state.children.values()];\n  shuffleArray(kids);\n  // console.log(`Recursively exploring all ${state.legalMoves.length} moves with depth ${depth}`);\n  if (maximizing) {\n    let value = Number.NEGATIVE_INFINITY;\n    for (const child of kids) {\n      value = Math.max(value, minMax({ state: child, alpha, beta, maxPlayer, depth: depth - 1, maximizing: false }));\n      alpha = Math.max(alpha, value);\n      if (value >= beta) {\n        break;\n      }\n    }\n    return value;\n  } else {\n    let value = Number.POSITIVE_INFINITY;\n    for (const child of kids) {\n      value = Math.min(value, minMax({ state: child, alpha, beta, maxPlayer, depth: depth - 1, maximizing: true }));\n      beta = Math.min(beta, value);\n      if (value <= alpha) {\n        break;\n      }\n    }\n    return value;\n  }\n}\n\n","import { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\n\n\nexport function evaluateState(state: State, evalPlayer: Player) {\n  // (already computed) Perform BFS for both pawns to get distance to finishline\n  const d1 = state.shortestPaths[evalPlayer];\n  const otherPlayer = evalPlayer === Player.white ? Player.black : Player.white;\n  const d2 = state.shortestPaths[otherPlayer];\n  if (state.automaticPlayoutPossible) {\n    // The one with shorter distance wins\n    // But check if a jump could influence it!\n    // TODO: do it correctly with taking account for jumps\n    // jumps should not be a problem if difference bigger than 1\n    // or the distance to the enemy pawn is farther than to the end\n    // Wait: we can just play it out\n    return state.automaticPlayout() === evalPlayer ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  }\n  // factor in the walls available\n  return d2 - d1 + 0.1 * state.wallsAvailable[evalPlayer] - 0.1 * state.wallsAvailable[otherPlayer] + Math.random() * 0.1;\n  // return (30-d1) + d2 + 10 +  Math.random() * 5;\n}\n","import { Notation, posToString } from \"../quoridor/Notation\";\nimport { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\n\n\nexport async function shortestPathMove(state: State): Promise<Notation> {\n    let d = Number.POSITIVE_INFINITY;\n    let shortestMove = \"INITIALIZED\";\n    for (const move of state.generatePawnMoves(state.pawnPositions[state.currentPlayer])) {\n        const [row, col] = move.target;\n        const dist = state.currentPlayer === Player.white ? state.board[row][col] : state.board[row-1][col-1];\n        if (dist !== -1 && dist < d) {\n            d = dist;\n            shortestMove = posToString(move.target);\n        }\n    }\n\n    return shortestMove;\n}\n\nexport const ShortestPathAgent = {\n    isMachine: true,\n    name: 'ShortestPath',\n    getMove: shortestPathMove,\n};\n","import { State } from \"../quoridor/State\";\nimport { MCTSSearch } from \"./MCTSNode\";\nimport { minMax } from \"./minMax\";\n\n/*\n * Wepback complains if we try to use different Workers.\n * To circumvent this issue we pass an event type as the first element in the data array\n * and perform the work depending on that value.\n */\nexport enum workTypes {\n    MINMAX = \"MINMAX\",\n    MCTS = \"MCTS\",\n}\n\nonmessage = async function(e) {\n    switch (e.data[0]) {\n        case workTypes.MINMAX:\n            minMaxWorker(e.data.splice(1));\n            break;\n        case workTypes.MCTS:\n            mctsWorker(e.data.splice(1));\n            break;\n        default:\n            break;\n    }\n}\n\nasync function mctsWorker(data: any) {\n  const [stateNotation, settings, simulations] = data;\n    console.log(\"received\", data)\n  try {\n    const state = State.fromNotation(stateNotation, settings);\n    const search = new MCTSSearch(state)\n    const move = await search.bestAction(simulations);\n    console.log(\"sent\", [move])\n    postMessage([move]);\n  } catch (e) {\n    console.error(e, stateNotation);\n  }\n}\nfunction minMaxWorker(data: any) {\n  const [move, stateNotation, settings, alpha, beta, maxPlayer, depth, maximizing] = data;\n  try {\n    const state = State.fromNotation(stateNotation, settings);\n    const value = minMax({state, alpha, beta, maxPlayer, depth, maximizing});\n    postMessage([move, value]);\n  } catch (e) {\n    console.error(e, stateNotation);\n  }\n}\n\n","import { Move } from \"../quoridor/Move\";\nimport { isPawnMove, moveToNotation, Notation } from \"../quoridor/Notation\";\nimport { Player } from \"../quoridor/Player\";\nimport { State } from \"../quoridor/State\";\nimport Company from \"./Company\";\nimport { minMaxWrapper } from \"./minMax\";\nimport { shortestPathMove } from \"./ShortestPathAgent\";\nimport { selectRandomly, shuffleArray } from \"./utils\";\n\nexport class MCTSNode {\n    state: State;\n    n: number = 0; // number of visits\n    v: number = 0; // value of the node\n    parent: MCTSNode | null;\n    children: MCTSNode[] = [];\n    untriedActions: Notation[];\n    move: Notation;\n    UCTparam = Math.sqrt(2);\n    player: Player;\n\n    constructor(state: State, parent: MCTSNode | null, move: Notation, player: Player) {\n        this.state = state;\n        this.parent = parent;\n        this.untriedActions = [...state.legalMoves];\n        this.move = move;\n        this.player = player;\n    }\n\n    expand() {\n        const move = this.untriedActions.pop();\n        if (!move) {\n            throw new Error(\"Node is already fully expanded\");\n        }\n        const nextState = this.state.makeMove(move);\n        const childNode = new MCTSNode(nextState, this, move, this.player);\n        this.children.push(childNode);\n        return childNode;\n    }\n    get isFullyExpanded() {\n        return this.untriedActions.length === 0;\n    }\n\n    get UCT() {\n        /*\n         * Upper Confidence Bound for Trees\n         * We may need to fine tune UCTparam\n         */\n        if (this.parent === null || this.parent.n === 0) {\n            throw new Error(\"UCT called on root\");\n        } else if (this.n === 0) {\n            return Number.POSITIVE_INFINITY;\n        } else {\n            return this.v / this.n + this.UCTparam * Math.sqrt(Math.log(this.parent.n) / this.n) ;\n        }\n    }\n\n    bestChild(): MCTSNode {\n        /*\n         * Selects the child node with the highest UCT value\n         */\n        if (this.children.length === 0) {\n            throw new Error(\"MCTSNode has no children\");\n        }\n        let t = [this.children[0]];\n        let m = t[0].UCT;\n        for (const c of this.children) {\n           if (c.UCT > m)  {\n              m = c.UCT;\n              t = [c];\n           } else if (c.UCT === m) {\n               t.push(c);\n           }\n        }\n        return selectRandomly(t);\n    }\n\n    childWithMostVisits() {\n        if (this.children.length === 0) {\n            throw new Error(\"No children to choose from\");\n        }\n        let index = 0;\n        let maxVisits = this.children[0].n;\n        for (let i = 1; i < this.children.length; i++) {\n            if (this.children[i].n > maxVisits) {\n                maxVisits = this.children[i].n;\n                index = i;\n            }\n        }\n        return this.children[index];\n    }\n\n    get isLeaf() {\n        return this.children.length === 0;\n    }\n\n    get isTerminal() {\n        if (this.state.isGameOver()) {\n            return true;\n        } else if (this.state.automaticPlayoutPossible) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    async rolloutPolicy(state: State): Promise<Notation> {\n        return minMaxWrapper(state, 1, null, this.player);\n    }\n\n    async rollout(): Promise<number> {\n        let currentState = this.state.clone();\n        while (!currentState.isGameOver && !currentState.automaticPlayoutPossible) {\n            // Heuristic from Gorisanon\n            if (currentState.wallsAvailable[currentState.currentPlayer]) {\n                const move = await shortestPathMove(currentState);\n                currentState = currentState.makeMoveInplace(move);\n            } else if (Math.random() < 0.7) {\n                const move = await shortestPathMove(currentState);\n                currentState = currentState.makeMoveInplace(move);\n            } else {\n                // TODO Choose a \"probable\" wall\n                const  move = selectRandomly([...currentState.legalMoves]);\n                currentState = currentState.makeMoveInplace(move);\n            }\n        }\n        return currentState.result(this.player);\n    }\n    backpropagate(result: number) {\n        this.n++;\n        this.v += result;\n        if (this.parent !== null) {\n            this.parent.backpropagate(result);\n        }\n    }\n}\n\nexport class MCTSSearch {\n    root: MCTSNode;\n\n    constructor(state: State) {\n        this.root = new MCTSNode(state, null, \"ROOT\", state.currentPlayer);\n    }\n\n\n    select() {\n        let current: MCTSNode = this.root;\n        while (!current.isTerminal) {\n            if (!current.isFullyExpanded) {\n                return current.expand();\n            } else {\n                current = current.bestChild();\n            }\n        }\n        return current;\n    }\n\n    async bestAction(simulations=1000): Promise<Notation> {\n        for (let i=0;i<simulations;i++) {\n            const leaf = this.select();\n            const reward = await leaf.rollout();\n            leaf.backpropagate(reward);\n        }\n        const res = this.root.childWithMostVisits().move;\n        return res;\n    }\n}\n"],"names":["Orientation","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","minLen","n","toString","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","_typeof","_regeneratorRuntime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","configurable","writable","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","_toConsumableArray","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","Player","ALPHABET","posToString","pos","Math","floor","ceil","notationToPos","notation","indexOf","Number","parseInt","substring","notationToMove","endsWith","orientation","row","column","square","moveToNotation","move","GameSettingsDefaults","boardWidth","boardHeight","walls","pawns","State","settings","root","pawnPositions","wallsAvailable","board","currentPlayer","width","height","illegal","shortestPaths","turn","precomputedMoves","_children","middle","fill","map","Int8Array","j","whiteBFS","blackBFS","white","legalMoves","has","black","player","isGameOver","winner","automaticPlayout","ddiff","opponent","depth","layer","Set","add","jumpFlag","currPaths","nextLayer","col","ns","ws","ind","jumpDist","otherPaths","flag","size","newState","Map","res","children","placeWall","d1","d","_","pawnPos","enemyPos","generateManhattanMoves","c","direction","behind","q","pr","pc","v","shift","y","x","moves","generatePawnMoves","concat","generateWallMoves","m","generateAllMoves","makeMove","set","computeChildren","matches","match","hwalls","trim","split","vwalls","console","log","shuffleArray","random","selectRandomly","minMaxWrapper","workers","maxPlayer","start","performance","now","alpha","NEGATIVE_INFINITY","beta","POSITIVE_INFINITY","kids","entries","t","tempMove","promises","workloads","splice","worker","load","data","p","onmessage","stateNotation","toNotation","postMessage","workTypes","MINMAX","all","max","child","minMax","maximizing","evalPlayer","otherPlayer","d2","automaticPlayoutPossible","evaluateState","min","shortestPathMove","shortestMove","dist","MCTSNode","parent","untriedActions","UCTparam","sqrt","childNode","UCT","index","maxVisits","currentState","clone","makeMoveInplace","backpropagate","MCTSSearch","current","isTerminal","isFullyExpanded","expand","bestChild","simulations","leaf","select","rollout","reward","childWithMostVisits","mctsWorker","fromNotation","search","bestAction","minMaxWorker","MCTS"],"sourceRoot":""}